<!DOCTYPE html> 
<html> 
<head> 
<style>
	#heading{
	 position:absolute;
	 text-align:center;
	 width:100vw;
	}
</style> 
</head>
<body>  


<div id='heading'>
 <h1 style ='color:red'>Billboard </h1>
</div>

<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>


<script type ="module">
javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='https://mrdoob.github.io/stats.js/build/stats.min.js';document.head.appendChild(script);})()

import * as THREE from 'https://unpkg.com/three/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';

var scene, renderer, camera;
var faces,which,number;


init(); 
animate(); 

function init() { 

	var width = window.innerWidth;
    var height = window.innerHeight;

    renderer = new THREE.WebGLRenderer({
        antialias: true
    });
    renderer.setSize(width, height);
    document.body.appendChild(renderer.domElement);
    renderer.setClearColor(0x888888);

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);
    camera.position.set (0, 100, 200);

    let controls = new OrbitControls(camera, renderer.domElement);

    var gridXZ = new THREE.GridHelper(200, 20, 'red', 'white');
    scene.add(gridXZ);
 
	///////////////////////////////////////////////////////////////////////////////
	
	var loader = new THREE.TextureLoader();
	loader.crossOrigin = '';
	let texture = loader.load('https://i.imgur.com/ZOydMXd.png');
	let texMat = new THREE.MeshBasicMaterial({
		map: texture,
		alphaTest: 0.5,
		side:THREE.DoubleSide,
		polygonOffset: true,
		polygonOffsetFactor: -1.0,
		polygonOffsetUnits: -4.0
	});
	number = new THREE.Mesh(buildGeometry(), texMat);
	texture.wrapS = THREE.RepeatWrapping;
	texture.wrapT = THREE.RepeatWrapping;
	scene.add(number);
	
	var dice = new THREE.Group();
    scene.add (dice);
    
    // only test 3 faces (px, py, pz);
    
    let px = new THREE.Mesh (new THREE.PlaneGeometry (30,30), new THREE.MeshBasicMaterial({color:0xff0000, transparent:true, opacity:0.4}));
    dice.add (px);
    px.rotation.y = Math.PI/2;
    px.position.set (15,0,0);
    
    let py = new THREE.Mesh (new THREE.PlaneGeometry (30,30), new THREE.MeshBasicMaterial({color:0x00ff00, transparent:true, opacity:0.4}));
    dice.add (py);
    py.rotation.x = -Math.PI/2;
    py.position.set (0, 15,0);
    
    let pz = new THREE.Mesh (new THREE.PlaneGeometry (30,30), new THREE.MeshBasicMaterial({color:0x0000ff, transparent:true, opacity:0.4}));
    dice.add (pz);
    pz.position.set (0, 0, 15);
	
	let pk = new THREE.Mesh (new THREE.PlaneGeometry (30,30), new THREE.MeshBasicMaterial({color:0xffff00, transparent:true, opacity:0.4}));
    dice.add (pk);
	pk.rotation.y = Math.PI;
	pk.rotation.z = Math.PI/2;
    pk.position.set (0, 0, -15);
	
	let pm = new THREE.Mesh (new THREE.PlaneGeometry (30,30), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.4}));
    dice.add (pm);
	pm.rotation.y = -Math.PI/2;
    pm.position.set (-15, 0, 0);
	
	let pn = new THREE.Mesh (new THREE.PlaneGeometry (30,30), new THREE.MeshBasicMaterial({color:0xffC0CB, transparent:true, opacity:0.4}));
    dice.add (pn);
	pn.rotation.x = Math.PI/2;
    pn.position.set (0, -15, 0);
    
    faces = {'px': px, 'py':py, 'pz':pz,'pk':pk,'pm':pm,'pn':pn};
	setTimeout (countDown, 0);
}

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}
function countDown() {

	setTimeout (countDown, 1000);
	if (number) {
		var texture = number.material.map;
			texture.offset.x -= 1/5;
		if (texture.offset.x === Math.floor(texture.offset.x))
			texture.offset.y -= 1;
	}
}
function buildGeometry() {

	var geometry = new THREE.Geometry();
		geometry.vertices.push(
		new THREE.Vector3(-15, -15, 0),
		new THREE.Vector3(15, -15, 0),
		new THREE.Vector3(15, 15, 0),
		new THREE.Vector3(-15, 15, 0)
	);

	var face;
	face = new THREE.Face3(0, 1, 2);
	geometry.faces.push(face);
	face = new THREE.Face3(0, 2, 3);
	geometry.faces.push(face);

	var st0 = new THREE.Vector2(0.8,0);
	var st1 = new THREE.Vector2(1, 0);
	var st2 = new THREE.Vector2(1, 1);
	var st3 = new THREE.Vector2(0.8, 1);
	geometry.faceVertexUvs[0].push([st0, st1, st2]);
	geometry.faceVertexUvs[0].push([st0, st2, st3]);

	geometry.computeBoundingSphere();
	geometry.computeFaceNormals();
	geometry.computeVertexNormals();
	return geometry;
}

function searchFace () {
	var maxDot = -1;
  
	var normals = {px: new THREE.Vector3(1,0,0), py: new THREE.Vector3(0,1,0), pz: new THREE.Vector3(0,0,1),pk: new THREE.Vector3(0,0,-1),pm: new THREE.Vector3(-1,0,0),pn: new THREE.Vector3(0,-1,0)};
	var centers = {px: new THREE.Vector3(15,0,0), py: new THREE.Vector3(0,15,0), pz: new THREE.Vector3(0,0,15),pk: new THREE.Vector3(0,0,-15),pm: new THREE.Vector3(-15,0,0),pn: new THREE.Vector3(0,-15,0)};
  
	let dd, point;
	point = camera.position.clone().sub (centers['px']).normalize();
	if ((dd = normals['px'].dot (point)) > maxDot) {
		maxDot = dd;
		which = 'px';
	}
	point = camera.position.clone().sub (centers['py']).normalize();
	if ((dd = normals['py'].dot (point)) > maxDot) {
		maxDot = dd;
		which = 'py';
	}
	point = camera.position.clone().sub (centers['pz']).normalize();
	if ((dd = normals['pz'].dot (point)) > maxDot) {
		maxDot = dd;
		which = 'pz';
	}
	point = camera.position.clone().sub (centers['pk']).normalize();
	if ((dd = normals['pk'].dot (point)) > maxDot) {
		maxDot = dd;
		which = 'pk';
	}
	point = camera.position.clone().sub (centers['pm']).normalize();
	if ((dd = normals['pm'].dot (point)) > maxDot) {
		maxDot = dd;
		which = 'pm';
	}
	point = camera.position.clone().sub (centers['pn']).normalize();
	if ((dd = normals['pn'].dot (point)) > maxDot) {
		maxDot = dd;
		which = 'pn';
	}
		return which;
}

function setAllFacesTransparent () {
	faces['px'].material.transparent = true;
	faces['py'].material.transparent = true;
	faces['pz'].material.transparent = true;
	faces['pk'].material.transparent = true;
	faces['pm'].material.transparent = true;
	faces['pn'].material.transparent = true;
}

function animate() {

	setAllFacesTransparent();
  

	which = searchFace();
    faces[which].material.transparent = false;
	
	if(number){
		number.position.copy(faces[which].position);
		number.rotation.copy(faces[which].rotation);
		if(which === 'pm') //white
			number.rotation.y = -Math.PI/2;
		else if(number === 'pn'){ //pink
			number.rotation.x = Math.PI/2;
		}
		else if(which === 'pk') //yellow
			number.rotation.z = Math.PI/2;
	}

	renderer.render (scene, camera); 
	requestAnimationFrame( animate ); 
}




</script> 

</body>