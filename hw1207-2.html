<!DOCTYPE html> 
<html> 
<head> 
<style>
	#heading{
	 position:absolute;
	 text-align:center;
	 width:100vw;
	}
</style> 
</head>
<body>  


<div id='heading'>
 <h1 style ='color:red'>Billboard </h1>
</div>

<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>


<script type ="module">
javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='https://mrdoob.github.io/stats.js/build/stats.min.js';document.head.appendChild(script);})()

import * as THREE from 'https://unpkg.com/three/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';

var scene, renderer, camera;
var meshMaterial;
var faces,which;


init(); 
animate(); 

function init() { 

	var width = window.innerWidth;
    var height = window.innerHeight;

    renderer = new THREE.WebGLRenderer({
        antialias: true
    });
    renderer.setSize(width, height);
    document.body.appendChild(renderer.domElement);
    renderer.setClearColor(0x888888);

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);
    camera.position.set (0, 100, 200);

    let controls = new OrbitControls(camera, renderer.domElement);

    var gridXZ = new THREE.GridHelper(200, 20, 'red', 'white');
    scene.add(gridXZ);
 
	///////////////////////////////////////////////////////////////////////////////
	
	var dice = new THREE.Group();
    scene.add (dice);
    
    // only test 3 faces (px, py, pz);
    
    let px = new THREE.Mesh (new THREE.PlaneGeometry (30,30), new THREE.MeshBasicMaterial({color:0xff0000, transparent:true, opacity:0.4}));
    dice.add (px);
    px.rotation.y = Math.PI/2;
    px.position.set (15,0,0);
    
    let py = new THREE.Mesh (new THREE.PlaneGeometry (30,30), new THREE.MeshBasicMaterial({color:0x00ff00, transparent:true, opacity:0.4}));
    dice.add (py);
    py.rotation.x = -Math.PI/2;
    py.position.set (0, 15,0);
    
    let pz = new THREE.Mesh (new THREE.PlaneGeometry (30,30), new THREE.MeshBasicMaterial({color:0x0000ff, transparent:true, opacity:0.4}));
    dice.add (pz);
    pz.position.set (0, 0, 15);
	
	let pk = new THREE.Mesh (new THREE.PlaneGeometry (30,30), new THREE.MeshBasicMaterial({color:0xffff00, transparent:true, opacity:0.4}));
    dice.add (pk);
	pk.rotation.y = Math.PI;
	pk.rotation.z = Math.PI/2;
    pk.position.set (0, 0, -15);
	
	let pm = new THREE.Mesh (new THREE.PlaneGeometry (30,30), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.4}));
    dice.add (pm);
	pm.rotation.y = -Math.PI/2;
    pm.position.set (-15, 0, 0);
	
	let pn = new THREE.Mesh (new THREE.PlaneGeometry (30,30), new THREE.MeshBasicMaterial({color:0xffC0CB, transparent:true, opacity:0.4}));
    dice.add (pn);
	pn.rotation.x = Math.PI/2;
    pn.position.set (0, -15, 0);
    
    faces = {'px': px, 'py':py, 'pz':pz,'pk':pk,'pm':pm,'pn':pn};
}

function searchFace () {
	var maxDot = -1;
  
	var normals = {px: new THREE.Vector3(1,0,0), py: new THREE.Vector3(0,1,0), pz: new THREE.Vector3(0,0,1),pk: new THREE.Vector3(0,0,-1),pm: new THREE.Vector3(-1,0,0),pn: new THREE.Vector3(0,-1,0)};
	var centers = {px: new THREE.Vector3(15,0,0), py: new THREE.Vector3(0,15,0), pz: new THREE.Vector3(0,0,15),pk: new THREE.Vector3(0,0,-15),pm: new THREE.Vector3(-15,0,0),pn: new THREE.Vector3(0,-15,0)};
  
	let dd, point;
	point = camera.position.clone().sub (centers['px']).normalize();
	if ((dd = normals['px'].dot (point)) > maxDot) {
		maxDot = dd;
		which = 'px';
	}
	point = camera.position.clone().sub (centers['py']).normalize();
	if ((dd = normals['py'].dot (point)) > maxDot) {
		maxDot = dd;
		which = 'py';
	}
	point = camera.position.clone().sub (centers['pz']).normalize();
	if ((dd = normals['pz'].dot (point)) > maxDot) {
		maxDot = dd;
		which = 'pz';
	}
	point = camera.position.clone().sub (centers['pk']).normalize();
	if ((dd = normals['pk'].dot (point)) > maxDot) {
		maxDot = dd;
		which = 'pk';
	}
	point = camera.position.clone().sub (centers['pm']).normalize();
	if ((dd = normals['pm'].dot (point)) > maxDot) {
		maxDot = dd;
		which = 'pm';
	}
	point = camera.position.clone().sub (centers['pn']).normalize();
	if ((dd = normals['pn'].dot (point)) > maxDot) {
		maxDot = dd;
		which = 'pn';
	}
		return which;
}

function setAllFacesTransparent () {
	faces['px'].material.transparent = true;
	faces['py'].material.transparent = true;
	faces['pz'].material.transparent = true;
	faces['pk'].material.transparent = true;
	faces['pm'].material.transparent = true;
	faces['pn'].material.transparent = true;
}

function animate() {

	setAllFacesTransparent();
  
    // go through all faces, determine which one facing camera
	let which = searchFace();
    faces[which].material.transparent = false;

	renderer.render (scene, camera); 
	requestAnimationFrame( animate ); 
}




</script> 

</body>